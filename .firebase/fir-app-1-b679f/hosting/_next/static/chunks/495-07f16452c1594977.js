"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[495],{4495:(e,t,r)=>{r.d(t,{z9:()=>U,LP:()=>G,yu:()=>X});var i=r(8885),n=r(2680),o=r(9504),a=r(9053);let s=new Map,l={activated:!1,tokenObservers:[]},c={initialized:!1,enabled:!1};function h(e){return s.get(e)||Object.assign({},l)}let u="https://content-firebaseappcheck.googleapis.com/v1",p={RETRIAL_MIN_WAIT:3e4,RETRIAL_MAX_WAIT:96e4};class d{constructor(e,t,r,i,n){if(this.operation=e,this.retryPolicy=t,this.getWaitDuration=r,this.lowerBound=i,this.upperBound=n,this.pending=null,this.nextErrorWaitInterval=i,i>n)throw Error("Proactive refresh lower bound greater than upper bound!")}start(){this.nextErrorWaitInterval=this.lowerBound,this.process(!0).catch(()=>{})}stop(){this.pending&&(this.pending.reject("cancelled"),this.pending=null)}isRunning(){return!!this.pending}async process(e){this.stop();try{var t;this.pending=new o.BH,this.pending.promise.catch(e=>{}),await (t=this.getNextRun(e),new Promise(e=>{setTimeout(e,t)})),this.pending.resolve(),await this.pending.promise,this.pending=new o.BH,this.pending.promise.catch(e=>{}),await this.operation(),this.pending.resolve(),await this.pending.promise,this.process(!0).catch(()=>{})}catch(e){this.retryPolicy(e)?this.process(!1).catch(()=>{}):this.stop()}}getNextRun(e){if(e)return this.nextErrorWaitInterval=this.lowerBound,this.getWaitDuration();{let e=this.nextErrorWaitInterval;return this.nextErrorWaitInterval*=2,this.nextErrorWaitInterval>this.upperBound&&(this.nextErrorWaitInterval=this.upperBound),e}}}let f=new o.LL("appCheck","AppCheck",{"already-initialized":"You have already called initializeAppCheck() for FirebaseApp {$appName} with different options. To avoid this error, call initializeAppCheck() with the same options as when it was originally called. This will return the already initialized instance.","use-before-activation":"App Check is being used before initializeAppCheck() is called for FirebaseApp {$appName}. Call initializeAppCheck() before instantiating other Firebase services.","fetch-network-error":"Fetch failed to connect to a network. Check Internet connection. Original error: {$originalErrorMessage}.","fetch-parse-error":"Fetch client could not parse response. Original error: {$originalErrorMessage}.","fetch-status-error":"Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.","storage-open":"Error thrown when opening storage. Original error: {$originalErrorMessage}.","storage-get":"Error thrown when reading from storage. Original error: {$originalErrorMessage}.","storage-set":"Error thrown when writing to storage. Original error: {$originalErrorMessage}.","recaptcha-error":"ReCAPTCHA error.","initial-throttle":"{$httpStatus} error. Attempts allowed again after {$time}",throttled:"Requests throttled due to previous {$httpStatus} error. Attempts allowed again after {$time}"});function g(e=!1){var t;return e?null===(t=self.grecaptcha)||void 0===t?void 0:t.enterprise:self.grecaptcha}function k(e){if(!h(e).activated)throw f.create("use-before-activation",{appName:e.name})}function w(e){let t=Math.round(e/1e3),r=Math.floor(t/86400),i=Math.floor((t-86400*r)/3600),n=Math.floor((t-86400*r-3600*i)/60),o="";return r&&(o+=m(r)+"d:"),i&&(o+=m(i)+"h:"),o+=m(n)+"m:"+m(t-86400*r-3600*i-60*n)+"s"}function m(e){return 0===e?"00":e>=10?e.toString():"0"+e}async function v({url:e,body:t},r){let i,n;let o={"Content-Type":"application/json"},a=r.getImmediate({optional:!0});if(a){let e=await a.getHeartbeatsHeader();e&&(o["X-Firebase-Client"]=e)}let s={method:"POST",body:JSON.stringify(t),headers:o};try{i=await fetch(e,s)}catch(e){throw f.create("fetch-network-error",{originalErrorMessage:null==e?void 0:e.message})}if(200!==i.status)throw f.create("fetch-status-error",{httpStatus:i.status});try{n=await i.json()}catch(e){throw f.create("fetch-parse-error",{originalErrorMessage:null==e?void 0:e.message})}let l=n.ttl.match(/^([\d.]+)(s)$/);if(!l||!l[2]||isNaN(Number(l[1])))throw f.create("fetch-parse-error",{originalErrorMessage:`ttl field (timeToLive) is not in standard Protobuf Duration format: ${n.ttl}`});let c=1e3*Number(l[1]),h=Date.now();return{token:n.token,expireTimeMillis:h+c,issuedAtTimeMillis:h}}function E(e,t){let{projectId:r,appId:i,apiKey:n}=e.options;return{url:`${u}/projects/${r}/apps/${i}:exchangeDebugToken?key=${n}`,body:{debug_token:t}}}let b="firebase-app-check-store",T="debug-token",A=null;function y(){return A||(A=new Promise((e,t)=>{try{let r=indexedDB.open("firebase-app-check-database",1);r.onsuccess=t=>{e(t.target.result)},r.onerror=e=>{var r;t(f.create("storage-open",{originalErrorMessage:null===(r=e.target.error)||void 0===r?void 0:r.message}))},r.onupgradeneeded=e=>{let t=e.target.result;0===e.oldVersion&&t.createObjectStore(b,{keyPath:"compositeKey"})}}catch(e){t(f.create("storage-open",{originalErrorMessage:null==e?void 0:e.message}))}}))}async function C(e,t){let r=(await y()).transaction(b,"readwrite"),i=r.objectStore(b).put({compositeKey:e,value:t});return new Promise((e,t)=>{i.onsuccess=t=>{e()},r.onerror=e=>{var r;t(f.create("storage-set",{originalErrorMessage:null===(r=e.target.error)||void 0===r?void 0:r.message}))}})}async function P(e){let t=(await y()).transaction(b,"readonly"),r=t.objectStore(b).get(e);return new Promise((e,i)=>{r.onsuccess=t=>{let r=t.target.result;r?e(r.value):e(void 0)},t.onerror=e=>{var t;i(f.create("storage-get",{originalErrorMessage:null===(t=e.target.error)||void 0===t?void 0:t.message}))}})}function _(e){return`${e.options.appId}-${e.name}`}let I=new a.Yd("@firebase/app-check");async function R(e){if((0,o.hl)()){let t;try{t=await P(_(e))}catch(e){I.warn(`Failed to read token from IndexedDB. Error: ${e}`)}return t}}function S(e,t){return(0,o.hl)()?C(_(e),t).catch(e=>{I.warn(`Failed to write token to IndexedDB. Error: ${e}`)}):Promise.resolve()}async function x(){let e;try{e=await P(T)}catch(e){}if(e)return e;{let e=crypto.randomUUID();return C(T,e).catch(e=>I.warn(`Failed to persist debug token to IndexedDB. Error: ${e}`)),e}}function M(){return c.enabled}async function D(){if(c.enabled&&c.token)return c.token.promise;throw Error(`
            Can't get debug token in production mode.
        `)}let N={error:"UNKNOWN_ERROR"};async function $(e,t=!1,r=!1){let i,n;let o=e.app;k(o);let a=h(o),s=a.token;if(s&&!K(s)&&(a.token=void 0,s=void 0),!s){let e=await a.cachedTokenPromise;e&&(K(e)?s=e:await S(o,void 0))}if(!t&&s&&K(s))return{token:s.token};let l=!1;if(M())try{a.exchangeTokenPromise||(a.exchangeTokenPromise=v(E(o,await D()),e.heartbeatServiceProvider).finally(()=>{a.exchangeTokenPromise=void 0}),l=!0);let t=await a.exchangeTokenPromise;return await S(o,t),a.token=t,{token:t.token}}catch(e){return"appCheck/throttled"===e.code||"appCheck/initial-throttle"===e.code?I.warn(e.message):r&&I.error(e),F(e)}try{a.exchangeTokenPromise||(a.exchangeTokenPromise=a.provider.getToken().finally(()=>{a.exchangeTokenPromise=void 0}),l=!0),s=await h(o).exchangeTokenPromise}catch(e){"appCheck/throttled"===e.code||"appCheck/initial-throttle"===e.code?I.warn(e.message):r&&I.error(e),n=e}return s?n?i=K(s)?{token:s.token,internalError:n}:F(n):(i={token:s.token},a.token=s,await S(o,s)):i=F(n),l&&L(o,i),i}async function O(e){let t=e.app;k(t);let{provider:r}=h(t);if(M()){let r=await D(),{token:i}=await v(E(t,r),e.heartbeatServiceProvider);return{token:i}}{let{token:e}=await r.getToken();return{token:e}}}function B(e,t,r,i){let{app:n}=e,o=h(n);if(o.tokenObservers=[...o.tokenObservers,{next:r,error:i,type:t}],o.token&&K(o.token)){let t=o.token;Promise.resolve().then(()=>{r({token:t.token}),z(e)}).catch(()=>{})}o.cachedTokenPromise.then(()=>z(e))}function H(e,t){let r=h(e),i=r.tokenObservers.filter(e=>e.next!==t);0===i.length&&r.tokenRefresher&&r.tokenRefresher.isRunning()&&r.tokenRefresher.stop(),r.tokenObservers=i}function z(e){let{app:t}=e,r=h(t),i=r.tokenRefresher;i||(i=function(e){let{app:t}=e;return new d(async()=>{let r;if((r=h(t).token?await $(e,!0):await $(e)).error)throw r.error;if(r.internalError)throw r.internalError},()=>!0,()=>{let e=h(t);if(!e.token)return 0;{let t=e.token.issuedAtTimeMillis+(e.token.expireTimeMillis-e.token.issuedAtTimeMillis)*.5+3e5;return Math.max(0,(t=Math.min(t,e.token.expireTimeMillis-3e5))-Date.now())}},p.RETRIAL_MIN_WAIT,p.RETRIAL_MAX_WAIT)}(e),r.tokenRefresher=i),!i.isRunning()&&r.isTokenAutoRefreshEnabled&&i.start()}function L(e,t){for(let r of h(e).tokenObservers)try{"EXTERNAL"===r.type&&null!=t.error?r.error(t.error):r.next(t)}catch(e){}}function K(e){return e.expireTimeMillis-Date.now()>0}function F(e){return{token:o.US.encodeString(JSON.stringify(N),!1),error:e}}class W{constructor(e,t){this.app=e,this.heartbeatServiceProvider=t}_delete(){let{tokenObservers:e}=h(this.app);for(let t of e)H(this.app,t.next);return Promise.resolve()}}function j(e,t,r,i,n){r.ready(()=>{(function(e,t,r,i){let n=r.render(i,{sitekey:t,size:"invisible",callback:()=>{h(e).reCAPTCHAState.succeeded=!0},"error-callback":()=>{h(e).reCAPTCHAState.succeeded=!1}}),o=h(e);o.reCAPTCHAState=Object.assign(Object.assign({},o.reCAPTCHAState),{widgetId:n})})(e,t,r,i),n.resolve(r)})}async function q(e){k(e);let t=h(e).reCAPTCHAState,r=await t.initialized.promise;return new Promise((t,i)=>{let n=h(e).reCAPTCHAState;r.ready(()=>{t(r.execute(n.widgetId,{action:"fire_app_check"}))})})}class U{constructor(e){this._siteKey=e,this._throttleData=null}async getToken(){var e,t,r;let i;!function(e){if(e&&Date.now()-e.allowRequestsAfter<=0)throw f.create("throttled",{time:w(e.allowRequestsAfter-Date.now()),httpStatus:e.httpStatus})}(this._throttleData);let n=await q(this._app).catch(e=>{throw f.create("recaptcha-error")});if(!(null===(e=h(this._app).reCAPTCHAState)||void 0===e?void 0:e.succeeded))throw f.create("recaptcha-error");try{i=await v(function(e,t){let{projectId:r,appId:i,apiKey:n}=e.options;return{url:`${u}/projects/${r}/apps/${i}:exchangeRecaptchaV3Token?key=${n}`,body:{recaptcha_v3_token:t}}}(this._app,n),this._heartbeatServiceProvider)}catch(e){if(null===(t=e.code)||void 0===t?void 0:t.includes("fetch-status-error"))throw this._throttleData=function(e,t){if(404===e||403===e)return{backoffCount:1,allowRequestsAfter:Date.now()+864e5,httpStatus:e};{let r=t?t.backoffCount:0,i=(0,o.$s)(r,1e3,2);return{backoffCount:r+1,allowRequestsAfter:Date.now()+i,httpStatus:e}}}(Number(null===(r=e.customData)||void 0===r?void 0:r.httpStatus),this._throttleData),f.create("initial-throttle",{time:w(this._throttleData.allowRequestsAfter-Date.now()),httpStatus:this._throttleData.httpStatus});throw e}return this._throttleData=null,i}initialize(e){this._app=e,this._heartbeatServiceProvider=(0,i.qX)(e,"heartbeat"),(function(e,t){let r=new o.BH;h(e).reCAPTCHAState={initialized:r};let i=function(e){let t=`fire_app_check_${e.name}`,r=document.createElement("div");return r.id=t,r.style.display="none",document.body.appendChild(r),t}(e),n=g(!1);return n?j(e,t,n,i,r):function(e){let t=document.createElement("script");t.src="https://www.google.com/recaptcha/api.js",t.onload=e,document.head.appendChild(t)}(()=>{let n=g(!1);if(!n)throw Error("no recaptcha");j(e,t,n,i,r)}),r.promise})(e,this._siteKey).catch(()=>{})}isEqual(e){return e instanceof U&&this._siteKey===e._siteKey}}function X(e=(0,i.Mq)(),t){e=(0,o.m9)(e);let r=(0,i.qX)(e,"app-check");if(c.initialized||function(){let e=(0,o.Rd)();if(c.initialized=!0,"string"!=typeof e.FIREBASE_APPCHECK_DEBUG_TOKEN&&!0!==e.FIREBASE_APPCHECK_DEBUG_TOKEN)return;c.enabled=!0;let t=new o.BH;c.token=t,"string"==typeof e.FIREBASE_APPCHECK_DEBUG_TOKEN?t.resolve(e.FIREBASE_APPCHECK_DEBUG_TOKEN):t.resolve(x())}(),M()&&D().then(e=>console.log(`App Check debug token: ${e}. You will need to add it to your app's App Check settings in the Firebase console for it to work.`)),r.isInitialized()){let i=r.getImmediate(),n=r.getOptions();if(n.isTokenAutoRefreshEnabled===t.isTokenAutoRefreshEnabled&&n.provider.isEqual(t.provider))return i;throw f.create("already-initialized",{appName:e.name})}let n=r.initialize({options:t});return function(e,t,r=!1){var i;let n=(i=Object.assign({},l),s.set(e,i),s.get(e));n.activated=!0,n.provider=t,n.cachedTokenPromise=R(e).then(t=>(t&&K(t)&&(n.token=t,L(e,{token:t.token})),t)),n.isTokenAutoRefreshEnabled=r&&e.automaticDataCollectionEnabled,!e.automaticDataCollectionEnabled&&r&&I.warn("`isTokenAutoRefreshEnabled` is true but `automaticDataCollectionEnabled` was set to false during `initializeApp()`. This blocks automatic token refresh."),n.provider.initialize(e)}(e,t.provider,t.isTokenAutoRefreshEnabled),h(e).isTokenAutoRefreshEnabled&&B(n,"INTERNAL",()=>{}),n}async function G(e,t){let r=await $(e,t);if(r.error)throw r.error;if(r.internalError)throw r.internalError;return{token:r.token}}let Y="app-check-internal";(0,i.Xd)(new n.wA("app-check",e=>new W(e.getProvider("app").getImmediate(),e.getProvider("heartbeat")),"PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback((e,t,r)=>{e.getProvider(Y).initialize()})),(0,i.Xd)(new n.wA(Y,e=>{var t;return t=e.getProvider("app-check").getImmediate(),{getToken:e=>$(t,e),getLimitedUseToken:()=>O(t),addTokenListener:e=>B(t,"INTERNAL",e),removeTokenListener:e=>H(t.app,e)}},"PUBLIC").setInstantiationMode("EXPLICIT")),(0,i.KN)("@firebase/app-check","0.10.1")}}]);